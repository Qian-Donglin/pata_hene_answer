6th editionについての解答。

解答がおかしいとかがありましたら[Sen(@nonpro3)](https://twitter.com/nonpro3)のTwitterアカウントにDMやリプライ飛ばしてください。

[大体ここにある](https://laysakura.github.io/2020/01/13/Patterson-Hennessy-5th-Excersise02/)。

上で事足りると思うが、[ここにもあるよ！](https://takyshu98.hatenadiary.jp/entry/2016/07/25/234824)

ただし、これは最新の6th editionではないので、下に対応表と乗ってない問題の回答を載せる。

| 6th edition | old                |
| ----------- | ------------------ |
| 2.1         | 2.1                |
| 2.2         | 2.2                |
| 2.3         | 2.3                |
| 2.4         | 2.4                |
| なし        | 2.5                |
| なし        | 2.6                |
| 2.5         | 2.7                |
| 2.6         | 2.8                |
| 2.7         | 2.9                |
| 2.8         | 2.10               |
| 2.9         | 2.11               |
| 2.10        | 2.12               |
| 2.11        | 2.13               |
| 2.12        | 2.14               |
| 2.13        | 2.15               |
| 2.14        | 2.16               |
| 2.15        | 2.17               |
| 2.16        | 2.18               |
| 2.17        | 2.19               |
| 2.18        | 2.20               |
| 2.19        | 2.21               |
| 2.20        | 2.22               |
| 2.21        | 2.23               |
| 2.22        | 2.24(少し違う)     |
| 2.23        | 2.25               |
| 2.24        | 2.26               |
| 2.25        | 2.27               |
| 2.26        | 2.28               |
| 2.27        | 2.29               |
| 2.28        | 2.30               |
| 2.29        | 2.31               |
| なし        | 2.32               |
| 2.30        | 2.33               |
| 2.31        | 2.34               |
| 2.32        | 2.35               |
| 2.33        | 2.36               |
| 2.34        | 2.37               |
| 2.35        | 2.38(全てじゃない) |
| 2.36        | なし               |
| なし        | 2.39               |
| なし        | 2.40               |
| なし        | 2.41               |
| なし        | 2.42               |
| なし        | 2.43               |
| 2.37        | 2.44               |
| 2.38        | 2.45?(少し違う)    |

以下の者はすべて6th editionのもので新規追加された問題の回答。

# 2.22

## 2.22.1

jal命令は、J形式で、即値は32-6=26bit　これで実際のPCで使用される値は、2進数に直すと末尾が00なので、26bitは2bit左へシフトして28bitとして扱う。そしてその際、上位4bitはプログラムカウンタの値そのままとして使って、変更しない。今回は`0x 2000 0000`なので上位4bitは変更されず、PCはjal命令を使っても、`0x 2000 0000`のまま。

## 2.22.2

beq命令は即値は16bit。実際は2bit左にシフトした18bitぶんだけPCをずらすことができる。この場合、即値の18bit相当分を32bitに符合拡張して、PCと足し合わせた範囲へ行ける。すなわち、`0x 1FFF 0000 - 0x 2000 FFFF`

# 2.35

**問題文は\$t2について言及は一切ないが、**上のブログを参考する限り、

> レジスタ$t1にはアドレス0x10000000が保持されており，レジスタ$t2にはアドレス0x10000010が保持されているものとする．アドレス0x10000000に収められているデータ（16進数）は0x11223344であるとする．レジスタ$t2によって指されるアドレスには，どんな値が収められるか．

が本来の意味と思われる。

**`lbu`は1バイトぶんだけ、下の1-8桁に入れる命令　なお上の24bitは0埋めされる**。(`lb`なら符号拡張もされる)

## 2.35.1

ビッグエンディアンは、数字の上位桁がアドレスの小さい方になる。`0x11223344`なら、11側がアドレスが小さいので、**スタート(アドレスが小さい左端)から数えて1バイトぶんを下1-8桁に入れるlbu**は、`0x00000011`となる。それを`$t2`にロードしてるので、`$t2`にあるのは`0x00000011`。

## 2.35.2

リトルエンディアンは、数字の下位桁がアドレスの小さい方になっている。`0x11223344`なら、44側がアドレスが小さいので、`lbu`でロードする1バイトぶんは`44`となり、それは`$t0`では**上1-8桁に入れる。**よって`$t2`にあるのは`0x44000000`。

**ここは確信をもって正解かどうかわからない。**

# 2.36

> LL/SCは特殊なLoad/Store命令の対で、まずデータ更新を行いたいアドレスから値をLL(Load)するが、この時読み込まれたアドレスには"Reserve"というフラグを付加する。このフラグは同じアドレスに書き込みが発生した場合消える。
> 次にSC(Store)によって新しい値をアドレスに書き込むが、この時SCは"Reserve"フラグが消えていれば書きこみを行わない。

```s
again:	addi	$t0, $zero, 1 # ロック状態であると示すデフォルト値1を代入
		ll		$t1, 0($s1) # $s1 + 0のアドレスのデータを$t1へロード。
		sc		$t0, 0($s1) # #s1 + 0のデータはロック状態にないなら、1が$t0に入るはず。
		beq		$t0, $zero, again # 0になっていたらロック状態ということで、againへ戻って再度ロードを試みる。
		add		$s4, $zero, $t1 # ロード成功した値を代入する。
```

これが`ll/sc`であり、これそのままが答え。

# 2.37

```c
void setmax(int *shvar, int x){
	if(x > *shvar)
		*shvar = x;
}
```

これをAtomicなものにするアセンブリコードを書く。`*shvar, x`は`$a0, $a1`にあるものとする。

```s
again:	addi		$t0, $zero, 1 # $t0を1で初期化
		ll			$t1, 0($a0)	# *shvarをロード
		slt			$t1, $a1, $t2 # *shvar < xならば、$t2に1を入れる。
		addi		$t3, $t3, 0 # $t3に1を入れて、beqの比較のために使う
		beq			$t3, $t1, end # *shvar < xでないならば、更新の必要がないのでラベルendまで飛ぶ。
		# これより下が同期更新するステップ。
		sc			$t0, 0($a0) # ロック状態にないなら、1がはいるはず。
		beq			$t0, $zero, end # ロック状態ならば、他のところで更新されたということ。代入はやめる。
		sw			$a1, 0($a0) # 代入
end: 
```

# 2.38

2.37の部分を同時に実行をし始めると、どちらかが先に`*shvar`をロードすると、後の方はsvの実行で`$t0`に0が入り、それでswは実行されず、endまで飛ばされる。

