6th editionについての解答。

解答がおかしいとかがありましたら[Sen(@nonpro3)](https://twitter.com/nonpro3)のTwitterアカウントにDMやリプライ飛ばしてください。
**この章に関してはかなり怪しいところが多いので、ぜひ教えてください。**

[大体ここにある](https://laysakura.github.io/2020/01/28/Patterson-Hennessy-5th-Excersise04/)。
だが、途中までしかないので、ない分で私が埋められるものを下に記述する。

ただし、これは最新の6th editionではないので、下に対応表と乗ってない問題の回答を載せる。

| 6th edition | old  |
| ----------- | ---- |
| 4.1         | 4.1  |
| 4.2         | なし |
| 4.3         | なし |
| 4.4         | なし |
| 4.5         | なし |

# 4.2

- RegDstのswは、書き込むレジスタも存在、書き込むデータも存在しない(メモリに書き込むので)ので、この時の書き込みレジスタが20-16bitか、15-11bitは関係ない。
- 同様に、RegDstのbeq命令も、同様にレジスタへ書き込まないし値はレジスタに入れないので、どっちでもいい。
- MemToRegはメモリからの読出しデータがレジスタに入るかどうかの制御線。そもそもメモリから読み出ししないswやbeqはどうなってもいい。

# 4.3

メモリ混合割合は

| R形式 | 非ロードI形式 | ロード | ストア | 分岐 | ジャンプ |
| ----- | ------------- | ------ | ------ | ---- | -------- |
| 24%   | 28%           | 25%    | 10%    | 11%  | 2%       |

各部品の使用状況は

|              | R形式 | 非ロードI形式 | ロード | ストア | 分岐 | ジャンプ | 合計     |
| ------------ | ----- | ------------- | ------ | ------ | ---- | -------- | -------- |
|              | 24%   | 28%           | 25%    | 10%    | 11%  | 2%       | 100%     |
| データメモリ | ×     | ×             | 〇     | 〇     | ×    | ×        | **35%**  |
| 命令メモリ   | 〇    | 〇            | 〇     | 〇     | 〇   | 〇       | **100%** |
| 符号拡張     |       |               |        |        | 〇   |          | **11%**  |

# 4.4

## 4.4.1

MemToRegはメモリからレジスタへデータを書き込む制御線。なので、lwが使用できなくなる。実質的にALUが無効化されるため致命的な問題である。

## 4.4.2

ALUsrcは0ならばrtのレジスタの値を、1ならば16bitの即値をALUに入れる。なので、即値含む命令が使用できなくなる。

# 4.5(未回答)

`0x00c6ba23`は、opecode = 0であり、R形式だとわかる。
つまり、`0000 0000 1100 0110 1011 1010 0010 0011`は、`000000 | 00110 | 00110 | 10111 | 01000 | 100011`であり、

`subu	$s7, $$a2, $a2`という命令になる。

# 4.6

# 4.6.1

図4.21で追加するべきなのは、**命令\[15-0\]を符号拡張せずにALUに入れるマルチプレクサと、それを制御するための制御線。**
このままではアドレス用に即値を4倍してbeqの比較か、メモリ読み出し格込みしかできない。

# 4.6.2

先ほど作ったマルチプレクサは、1ならば4倍するアドレスを使う、0ならば即値をそのまま使う**IsImmAddrという制御線**を加えたとして、記述する。

| RegDst | ALUsrc | Memto-Reg | RegWrite | MemRead | MemWrite | Branch | ALUOp1   | ALUOp0   | IsImmaddr |
| ------ | ------ | --------- | -------- | ------- | -------- | ------ | -------- | -------- | --------- |
| 1      | 1      | 0         | 1        | 0       | 0        | 0      | わからぬ | わからぬ | 1         |

# 4.7

全ての共同手順は、まずいかの通り

1. 命令メモリから読み出す(+250)
2. 制御ユニットで制御線設定(+50)

ここまで300ps。

## 4.7.1

続きはこの通り。図4.19にある。

1. 命令を分解。ここでRegDstの制御のマルチプレクサを通る(+25)
2. レジスタ設定(+20)して、レジスタファイルから読み出す(+30)
3. それと同時並行で、制御ユニットから、ALU制御に入力(+50)　同時並行でちょうど終わるのでステップ2も併せて+50である。
4. 即値とのマルチプレクサ(ALUsrc)を通る(+25)
5. ALU演算(+200)
6. MemtoRegのマルチプレクサを通る(+25)

なので、合計は**625ps**。

## 4.7.2

手順は以下の通り。図4.20の通りに見れば問題はない。

1. 命令を分解。ここでRegDstの制御のマルチプレクサを通る(+25)
2. レジスタ設定(+20)して、レジスタファイルから読み出す(+30)
3. それと同時並行で即値の符号拡張を行う(+50)　同時並行でちょうど終わるのでステップ2も併せて+50である。
4. それと同時並行で、制御ユニットから、ALU制御に入力(+50)　同時並行でちょうど終わるのでステップ1、2も併せて+50である。
5. ALUsrcのマルチプレクサを通る(+25)
6. ALU演算(+200)
7. データ読み出し

ここまでで**600ps**(ただしメモリロード時間は見てない)

## 4.7.3

手順は以下の通りlwと同じである。

## 4.7.4

手順は以下の通り。図4.21の通りに見れば問題はない。

1. レジスタ設定(+20)して、レジスタファイルから読み出す(+30)
2. それと同時並行で即値の符号拡張を行う(+50)　同時並行でちょうど終わるのでステップ1も併せて+50である。
3. それと同時並行で、制御ユニットから、ALU制御に入力(+50)　同時並行でちょうど終わるのでステップ1、2も併せて+50である。
4. ALUsrcのマルチプレクサを通る(+25)
5. ALU演算(+200)
6. ステップ4と5の裏で、シフトしてPCを演算する。(+150)これはALU演算が終わるまでには終わるので、ロスにはならない。
7. 0判定とBranch制御線のANDゲートを通る(+5)
8. ステップ7の結果を制御線としたマルチプレクサを通る(+25)。

ここまでで**605ps**

## 4.7.5

非ロード型I形式はの手順は以下の通り。

1. 命令を分解。ここでRegDstの制御のマルチプレクサを通る(+25)
2. レジスタ設定(+20)して、レジスタファイルから読み出す(+30)
3. それと同時並行で即値の符号拡張を行った値と、即値そのままのどれを選ぶのか？のマルチプレクサを通る(これは図にはない)(+25)　同時並行でちょうど終わるのでステップ2も併せて+50である。
4. 3. それと同時並行で、制御ユニットから、ALU制御に入力(+50)　同時並行でちょうど終わるのでステップ1、2、3も併せて+50である。
5. ALUsrcのマルチプレクサを通る(+25)
6. ALU演算(+200)
7. memtoRegのマルチプレクサを通る(+25)

ここまでで**600ps**。

# 4.8

**書いてないけど4.7の設定を引き継いで解くことになっている**。

